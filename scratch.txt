fit_model <- function(tree, model, crown_age) {
  n <- Ntip(tree)

  # Estimate initial lambda using Yule approximation
  lambda_start <- log(n) / crown_age
  mu_start <- 0.01  # small extinction rate

  result <- NULL

  if (model == "constant") {
    # Constant birth-death model
    result <- fit_bd(tree, crown_age,
                     cst.lamb = TRUE,
                     cst.mu = TRUE,
                     lamb_par = lambda_start,
                     mu_par = mu_start)

    lambda_present <- result$lamb_par

  } else if (model == "exponential") {
    # Exponential time-varying speciation
    result <- fit_bd(tree, crown_age,
                     cst.lamb = FALSE,
                     expo.lamb = TRUE,
                     cst.mu = TRUE,
                     expo.mu = FALSE,
                     lamb_par = c(lambda_start, 0.01),  # λ0, α
                     mu_par = mu_start)

    # Get present-day speciation rate: λ(t) = λ₀ * exp(α * t)
    lambda_present <- result$lamb_par[1] * exp(result$lamb_par[2] * crown_age)

  } else if (model == "linear") {
    # Linear time-varying speciation
    result <- fit_bd(tree, crown_age,
                     cst.lamb = FALSE,
                     expo.lamb = FALSE,
                     cst.mu = TRUE,
                     expo.mu = FALSE,
                     lamb_par = c(lambda_start, 0.001),  # λ0, α
                     mu_par = mu_start)

    # Get present-day speciation rate: λ(t) = λ₀ + α * t
    lambda_present <- result$lamb_par[1] + result$lamb_par[2] * crown_age

  } else {
    stop(sprintf("Unknown model: %s", model))
  }

  # Handle possible fit errors
  if (is.null(result) || is.null(result$mu_par) || is.null(lambda_present)) {
    stop("RPANDA model fit returned incomplete result")
  }

  return(list(
    lambda = lambda_present,
    mu = result$mu_par,
    lambda_ci_lower = NA,
    lambda_ci_upper = NA,
    mu_ci_lower = NA,
    mu_ci_upper = NA,
    loglik = result$LH,
    aic = result$aicc,
    aicc = result$aicc,
    convergence = result$conv
  ))
}


















fit_model <- function(tree, model, crown_age) {
  
  if (model == "constant") {
    # Constant birth-death model
    cat("ASDFKASDFJKLSDAJF")

    result <- fit_bd(tree, crown_age, cst.lamb = TRUE, cst.mu = TRUE)

    return(list(
      lambda = result$lamb_par,
      mu = result$mu_par,
      lambda_ci_lower = NA,
      lambda_ci_upper = NA,
      mu_ci_lower = NA,
      mu_ci_upper = NA,
      loglik = result$LH,
      aic = result$aicc,
      aicc = result$aicc,
      convergence = result$conv
    ))
    
  } else if (model == "exponential") {
    # Exponential variation in birth rate
    result <- fit_bd(tree, crown_age, cst.lamb = FALSE, cst.mu = TRUE, 
                     expo.lamb = TRUE, expo.mu = FALSE)
    
    # Get present-day rates
    lambda_0 <- result$lamb_par[1]
    alpha <- result$lamb_par[2]
    lambda_present <- lambda_0 * exp(alpha * crown_age)
    
    return(list(
      lambda = lambda_present,
      mu = result$mu_par,
      lambda_ci_lower = NA,
      lambda_ci_upper = NA,
      mu_ci_lower = NA,
      mu_ci_upper = NA,
      loglik = result$LH,
      aic = result$aicc,
      aicc = result$aicc,
      convergence = result$conv
    ))
    
  } else if (model == "linear") {
    # Linear variation in birth rate
    result <- fit_bd(tree, crown_age, cst.lamb = FALSE, cst.mu = TRUE, 
                     expo.lamb = FALSE, expo.mu = FALSE)
    
    # Get present-day rates
    lambda_0 <- result$lamb_par[1]
    alpha <- result$lamb_par[2]
    lambda_present <- lambda_0 + alpha * crown_age
    
    return(list(
      lambda = lambda_present,
      mu = result$mu_par,
      lambda_ci_lower = NA,
      lambda_ci_upper = NA,
      mu_ci_lower = NA,
      mu_ci_upper = NA,
      loglik = result$LH,
      aic = result$aicc,
      aicc = result$aicc,
      convergence = result$conv
    ))
  }
  
  return(NULL)
}








#!/usr/bin/env Rscript

# RPANDA Analysis Script
# Estimates speciation and extinction rates from phylogenetic trees
# and adds them to existing parameter CSV files

# Load required libraries
if (!require("RPANDA", quietly = TRUE)) {
  cat("Installing RPANDA package...\n")
  install.packages("RPANDA")
  library(RPANDA)
}

if (!require("ape", quietly = TRUE)) {
  cat("Installing ape package...\n")
  install.packages("ape")
  library(ape)
}

if (!require("phytools", quietly = TRUE)) {
  cat("Installing phytools package...\n")
  install.packages("phytools")
  library(phytools)
}

if (!require("deSolve", quietly = TRUE)) {
  cat("Installing deSolve package...\n")
  install.packages("deSolve")
  library(deSolve)
}

# For data manipulation
if (!require("dplyr", quietly = TRUE)) {
  cat("Installing dplyr package...\n")
  install.packages("dplyr")
  library(dplyr)
}


# Parse command line arguments
args <- commandArgs(trailingOnly = TRUE)

if (length(args) < 2) {
  cat("Usage: Rscript rpanda_analysis.R <tree_folder> <csv_file> [output_csv]\n")
  cat("  tree_folder: Folder containing Newick tree files\n")
  cat("  csv_file: CSV file with GTR parameters (from Python script)\n")
  cat("  output_csv: Optional output CSV file name (default: adds '_with_rates.csv')\n")
  quit(status = 1)
}

tree_folder <- args[1]
csv_file <- args[2]
output_csv <- if (length(args) >= 3) args[3] else gsub("\\.csv$", "_with_rates.csv", csv_file)

# Function to estimate diversification rates using RPANDA
estimate_rates <- function(tree_file, models = c("constant", "exponential", "linear")) {
  cat(sprintf("Processing tree: %s\n", basename(tree_file)))
  
  tryCatch({
    # Read the tree
    tree <- read.tree(tree_file)
    

    
    # Check if tree is valid
    #if (is.null(tree) || !is.phylo(tree)) {
      #warning(sprintf("Invalid tree in file: %s", tree_file))
      #return(create_empty_result(tree_file, "Invalid tree"))
    #}
    

    # Basic tree statistics
    n_tips <- Ntip(tree)
    tree_length <- sum(tree$edge.length)
    
    if (n_tips < 3) {
      warning(sprintf("Tree has too few tips: %s", tree_file))
      return(create_empty_result(tree_file, "Too few tips", n_tips, tree_length))
    }
    
    # RPANDA requires ultrametric trees
    if (!is.ultrametric(tree)) {
      cat("  Tree is not ultrametric, attempting to make ultrametric...\n")
      tree <- chronos(tree, quiet = TRUE)
    }
    
    # Ensure tree has positive branch lengths
    if (any(tree$edge.length <= 0)) {
      tree$edge.length[tree$edge.length <= 0] <- 1e-6
    }

    if (!is.rooted(tree)) {
        cat("  Tree is unrooted, rooting using midpoint...\n")
        tree <- midpoint.root(tree)
    }
    
    # Get the crown age
    crown_age <- max(node.depth.edgelength(tree))
    
    if (crown_age <= 0) {
      warning(sprintf("Invalid crown age in tree: %s", tree_file))
      return(create_empty_result(tree_file, "Invalid crown age", n_tips, tree_length))
    }
    
    # Store results for different models
    model_results <- list()
    best_model <- NULL
    best_aic <- Inf
    
    # Try different diversification models
    for (model in models) {
      cat(sprintf("  Fitting %s model...\n", model))
      
      model_result <- tryCatch({
        fit_model(tree, model, crown_age)
      }, error = function(e) {
        cat(sprintf("    %s model failed: %s\n", model, e$message))
        NULL
      })
      
      if (!is.null(model_result)) {
        model_results[[model]] <- model_result
        
        # Track best model by AIC
        if (!is.na(model_result$aic) && model_result$aic < best_aic) {
          best_aic <- model_result$aic
          best_model <- model
        }
      }
    }
    
    # If all models failed, try simple birth-death
    if (length(model_results) == 0) {
      cat("  All RPANDA models failed, trying simple birth-death...\n")
      
      simple_result <- tryCatch({
        fit_simple_bd(tree)
      }, error = function(e) {
        cat(sprintf("    Simple BD failed: %s\n", e$message))
        NULL
      })
      
      if (!is.null(simple_result)) {
        model_results[["simple_bd"]] <- simple_result
        best_model <- "simple_bd"
      }
    }
    
    # Extract results from best model
    if (!is.null(best_model) && best_model %in% names(model_results)) {
      result <- model_results[[best_model]]
      
      return(list(
        file = basename(tree_file),
        speciation_rate = result$lambda,
        extinction_rate = result$mu,
        net_diversification = result$lambda - result$mu,
        relative_extinction = if (result$lambda > 0) result$mu / result$lambda else NA,
        speciation_ci_lower = result$lambda_ci_lower,
        speciation_ci_upper = result$lambda_ci_upper,
        extinction_ci_lower = result$mu_ci_lower,
        extinction_ci_upper = result$mu_ci_upper,
        loglik = result$loglik,
        aic = result$aic,
        aicc = result$aicc,
        method = paste0("RPANDA_", best_model),
        n_tips = n_tips,
        tree_length = tree_length,
        crown_age = crown_age,
        convergence = result$convergence,
        error = NA
      ))
    } else {
      return(create_empty_result(tree_file, "All models failed", n_tips, tree_length))
    }
    
  }, error = function(e) {
    warning(sprintf("Error processing tree %s: %s", tree_file, e$message))
    return(create_empty_result(tree_file, as.character(e$message)))
  })
}

# Helper function to fit different models
fit_model <- function(tree, model, crown_age) {
  n <- Ntip(tree)

  # Estimate initial lambda using Yule approximation
  lambda_start <- log(n) / crown_age
  mu_start <- 0.01  # small extinction rate

  result <- NULL

  if (model == "constant") {
    # Constant birth-death model
    result <- fit_bd(tree, crown_age,
                     cst.lamb = TRUE,
                     cst.mu = TRUE,
                     lamb_par = lambda_start,
                     mu_par = mu_start)

    lambda_present <- result$lamb_par

  } else if (model == "exponential") {
    # Exponential time-varying speciation
    result <- fit_bd(tree, crown_age,
                     cst.lamb = FALSE,
                     expo.lamb = TRUE,
                     cst.mu = TRUE,
                     expo.mu = FALSE,
                     lamb_par = c(lambda_start, 0.01),  # λ0, α
                     mu_par = mu_start)

    # Get present-day speciation rate: λ(t) = λ₀ * exp(α * t)
    lambda_present <- result$lamb_par[1] * exp(result$lamb_par[2] * crown_age)

  } else if (model == "linear") {
    # Linear time-varying speciation
    result <- fit_bd(tree, crown_age,
                     cst.lamb = FALSE,
                     expo.lamb = FALSE,
                     cst.mu = TRUE,
                     expo.mu = FALSE,
                     lamb_par = c(lambda_start, 0.001),  # λ0, α
                     mu_par = mu_start)

    # Get present-day speciation rate: λ(t) = λ₀ + α * t
    lambda_present <- result$lamb_par[1] + result$lamb_par[2] * crown_age

  } else {
    stop(sprintf("Unknown model: %s", model))
  }

  # Handle possible fit errors
  if (is.null(result) || is.null(result$mu_par) || is.null(lambda_present)) {
    stop("RPANDA model fit returned incomplete result")
  }

  return(list(
    lambda = lambda_present,
    mu = result$mu_par,
    lambda_ci_lower = NA,
    lambda_ci_upper = NA,
    mu_ci_lower = NA,
    mu_ci_upper = NA,
    loglik = result$LH,
    aic = result$aicc,
    aicc = result$aicc,
    convergence = result$conv
  ))
}

# Simple birth-death model as fallback
fit_simple_bd <- function(tree) {
  # Simple Yule model estimation
  n <- Ntip(tree)
  crown_age <- max(node.depth.edgelength(tree))
  
  # Yule model: lambda = ln(n) / crown_age
  lambda <- log(n) / crown_age
  mu <- 0  # No extinction in Yule model
  
  # Calculate log-likelihood for Yule model
  loglik <- (n - 2) * log(lambda) - lambda * sum(tree$edge.length)
  aic <- -2 * loglik + 2  # 1 parameter (lambda)
  
  return(list(
    lambda = lambda,
    mu = mu,
    lambda_ci_lower = NA,
    lambda_ci_upper = NA,
    mu_ci_lower = NA,
    mu_ci_upper = NA,
    loglik = loglik,
    aic = aic,
    aicc = aic + (2 * 2 * (2 + 1)) / (n - 2 - 1),  # AICc correction
    convergence = 0
  ))
}

# Helper function to create empty result
create_empty_result <- function(tree_file, error_msg, n_tips = NA, tree_length = NA) {
  return(list(
    file = basename(tree_file),
    speciation_rate = NA,
    extinction_rate = NA,
    net_diversification = NA,
    relative_extinction = NA,
    speciation_ci_lower = NA,
    speciation_ci_upper = NA,
    extinction_ci_lower = NA,
    extinction_ci_upper = NA,
    loglik = NA,
    aic = NA,
    aicc = NA,
    method = "RPANDA_failed",
    n_tips = n_tips,
    tree_length = tree_length,
    crown_age = NA,
    convergence = NA,
    error = error_msg
  ))
}

# Function to match tree files with CSV entries
match_files <- function(csv_file, tree_file) {
  # Extract base names without extensions
  csv_base <- tools::file_path_sans_ext(basename(csv_file))
  tree_base <- tools::file_path_sans_ext(basename(tree_file))
  
  # Try exact match first
  if (csv_base == tree_base) return(TRUE)
  
  # Try partial matching (in case extensions differ)
  if (grepl(csv_base, tree_base, fixed = TRUE) || 
      grepl(tree_base, csv_base, fixed = TRUE)) {
    return(TRUE)
  }
  
  return(FALSE)
}

# Main analysis
cat("Starting RPANDA analysis...\n")
cat(sprintf("Tree folder: %s\n", tree_folder))
cat(sprintf("CSV file: %s\n", csv_file))
cat(sprintf("Output file: %s\n", output_csv))

# Check if inputs exist
if (!file.exists(csv_file)) {
  stop(sprintf("CSV file not found: %s", csv_file))
}

if (!dir.exists(tree_folder)) {
  stop(sprintf("Tree folder not found: %s", tree_folder))
}

# Read the existing CSV file
cat("Reading CSV file...\n")
csv_data <- read.csv(csv_file, stringsAsFactors = FALSE)

# Find tree files
tree_extensions <- c("*.tre", "*.tree", "*.nwk", "*.newick", "*.phy")
tree_files <- c()
for (ext in tree_extensions) {
  tree_files <- c(tree_files, list.files(tree_folder, pattern = glob2rx(ext), 
                                        full.names = TRUE, ignore.case = TRUE))
}

if (length(tree_files) == 0) {
  stop(sprintf("No tree files found in folder: %s", tree_folder))
}

cat(sprintf("Found %d tree files\n", length(tree_files)))

# Process each tree
rate_results <- list()

for (tree_file in tree_files) {
  rates <- estimate_rates(tree_file)
  rate_results[[length(rate_results) + 1]] <- rates
}

# Convert results to data frame
rates_df <- do.call(rbind, lapply(rate_results, data.frame, stringsAsFactors = FALSE))

# Match tree results with CSV data
cat("Matching tree files with CSV entries...\n")

# Create a matching column
csv_data$tree_match <- NA
rates_df$csv_match <- NA

for (i in 1:nrow(csv_data)) {
  csv_file_name <- csv_data$file[i]
  
  for (j in 1:nrow(rates_df)) {
    tree_file_name <- rates_df$file[j]
    
    if (match_files(csv_file_name, tree_file_name)) {
      csv_data$tree_match[i] <- j
      rates_df$csv_match[j] <- i
      break
    }
  }
}

# Merge the data
cat("Merging data...\n")

# Initialize new columns in csv_data
rate_columns <- c("speciation_rate", "extinction_rate", "net_diversification", 
                 "relative_extinction", "speciation_ci_lower", "speciation_ci_upper",
                 "extinction_ci_lower", "extinction_ci_upper", "tree_loglik", 
                 "tree_aic", "tree_aicc", "diversification_method", "n_tips", 
                 "tree_length", "crown_age", "convergence", "tree_error")

for (col in rate_columns) {
  csv_data[[col]] <- NA
}

# Fill in the matched data
for (i in 1:nrow(csv_data)) {
  if (!is.na(csv_data$tree_match[i])) {
    match_idx <- csv_data$tree_match[i]
    
    csv_data$speciation_rate[i] <- rates_df$speciation_rate[match_idx]
    csv_data$extinction_rate[i] <- rates_df$extinction_rate[match_idx]
    csv_data$net_diversification[i] <- rates_df$net_diversification[match_idx]
    csv_data$relative_extinction[i] <- rates_df$relative_extinction[match_idx]
    csv_data$speciation_ci_lower[i] <- rates_df$speciation_ci_lower[match_idx]
    csv_data$speciation_ci_upper[i] <- rates_df$speciation_ci_upper[match_idx]
    csv_data$extinction_ci_lower[i] <- rates_df$extinction_ci_lower[match_idx]
    csv_data$extinction_ci_upper[i] <- rates_df$extinction_ci_upper[match_idx]
    csv_data$tree_loglik[i] <- rates_df$loglik[match_idx]
    csv_data$tree_aic[i] <- rates_df$aic[match_idx]
    csv_data$tree_aicc[i] <- rates_df$aicc[match_idx]
    csv_data$diversification_method[i] <- rates_df$method[match_idx]
    csv_data$n_tips[i] <- rates_df$n_tips[match_idx]
    csv_data$tree_length[i] <- rates_df$tree_length[match_idx]
    csv_data$crown_age[i] <- rates_df$crown_age[match_idx]
    csv_data$convergence[i] <- rates_df$convergence[match_idx]
    csv_data$tree_error[i] <- rates_df$error[match_idx]
  }
}

# Remove the temporary matching column
csv_data$tree_match <- NULL

# Write the output
cat("Writing results...\n")
write.csv(csv_data, output_csv, row.names = FALSE)

# Print summary
matched_count <- sum(!is.na(csv_data$speciation_rate))
total_csv <- nrow(csv_data)
total_trees <- nrow(rates_df)

cat("\n=== SUMMARY ===\n")
cat(sprintf("CSV entries: %d\n", total_csv))
cat(sprintf("Tree files processed: %d\n", total_trees))
cat(sprintf("Successful matches: %d\n", matched_count))
cat(sprintf("Output written to: %s\n", output_csv))

if (matched_count > 0) {
  cat("\n=== RATE ESTIMATES SUMMARY ===\n")
  spec_rates <- csv_data$speciation_rate[!is.na(csv_data$speciation_rate)]
  ext_rates <- csv_data$extinction_rate[!is.na(csv_data$extinction_rate)]
  net_div <- csv_data$net_diversification[!is.na(csv_data$net_diversification)]
  
  cat(sprintf("Speciation rate - Mean: %.4f, Range: %.4f - %.4f\n", 
              mean(spec_rates), min(spec_rates), max(spec_rates)))
  cat(sprintf("Extinction rate - Mean: %.4f, Range: %.4f - %.4f\n", 
              mean(ext_rates), min(ext_rates), max(ext_rates)))
  cat(sprintf("Net diversification - Mean: %.4f, Range: %.4f - %.4f\n", 
              mean(net_div), min(net_div), max(net_div)))
  
  # Show method distribution
  methods <- table(csv_data$diversification_method[!is.na(csv_data$diversification_method)])
  cat("\n=== MODELS USED ===\n")
  for (i in 1:length(methods)) {
    cat(sprintf("%s: %d cases\n", names(methods)[i], methods[i]))
  }
  
  # Show convergence status
  converged <- sum(csv_data$convergence[!is.na(csv_data$convergence)] == 0)
  total_converged <- sum(!is.na(csv_data$convergence))
  if (total_converged > 0) {
    cat(sprintf("\nConvergence: %d/%d (%.1f%%) models converged successfully\n", 
                converged, total_converged, 100 * converged / total_converged))
  }
  
  # Show any errors
  errors <- csv_data$tree_error[!is.na(csv_data$tree_error)]
  if (length(errors) > 0) {
    cat("\n=== ERRORS ===\n")
    error_table <- table(errors)
    for (i in 1:length(error_table)) {
      cat(sprintf("%s: %d cases\n", names(error_table)[i], error_table[i]))
    }
  }
}

cat("\nRPANDA analysis complete!\n")