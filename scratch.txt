import dendropy
import numpy as np
from scipy.optimize import minimize
import random
from typing import Dict, List, Tuple, Optional, Union
import math
from enum import Enum

class BirthDeathModel(Enum):
    """Birth-death model types"""
    BCSTDCST = "constant_constant"      # Birth Constant, Death Constant
    BEXPDCST = "exponential_constant"   # Birth Exponential, Death Constant
    BLINDCST = "linear_constant"        # Birth Linear, Death Constant
    BCSTDEXP = "constant_exponential"   # Birth Constant, Death Exponential
    BEXPDEXP = "exponential_exponential" # Birth Exponential, Death Exponential
    BLINDEXP = "linear_exponential"     # Birth Linear, Death Exponential
    BCSTDLIN = "constant_linear"        # Birth Constant, Death Linear
    BEXPDLIN = "exponential_linear"     # Birth Exponential, Death Linear
    BLINDLIN = "linear_linear"          # Birth Linear, Death Linear

class CoalescentModel(Enum):
    """Coalescent model types"""
    COALCST = "constant"        # Constant effective population size
    COALEXP = "exponential"     # Exponential population growth
    COALLIN = "linear"          # Linear population growth
    COALSTEP = "step"           # Step function population change
    COALLOG = "logistic"        # Logistic population growth

class HybridTreeGenerator:
    """
    Generate hybrid trees mixing custom birth-death and coalescent models
    with AIC-weighted transitions between models.
    """
    
    def __init__(self, taxa_namespace: dendropy.TaxonNamespace):
        self.taxa_namespace = taxa_namespace
        self.transition_points = []
        self.model_weights = {}
        
    def birth_rate_function(self, t: float, model: BirthDeathModel, params: Dict) -> float:
        """Calculate birth rate at time t for different BD models"""
        if model in [BirthDeathModel.BCSTDCST, BirthDeathModel.BCSTDEXP, BirthDeathModel.BCSTDLIN]:
            # Constant birth rate
            return params.get('lambda0', 0.5)
        
        elif model in [BirthDeathModel.BEXPDCST, BirthDeathModel.BEXPDEXP, BirthDeathModel.BEXPDLIN]:
            # Exponential birth rate: lambda(t) = lambda0 * exp(alpha * t)
            lambda0 = params.get('lambda0', 0.5)
            alpha = params.get('alpha', 0.1)
            return lambda0 * math.exp(alpha * t)
        
        elif model in [BirthDeathModel.BLINDCST, BirthDeathModel.BLINDEXP, BirthDeathModel.BLINDLIN]:
            # Linear birth rate: lambda(t) = lambda0 + alpha * t
            lambda0 = params.get('lambda0', 0.5)
            alpha = params.get('alpha', 0.1)
            return max(0, lambda0 + alpha * t)
        
        return 0.5  # Default
    
    def death_rate_function(self, t: float, model: BirthDeathModel, params: Dict) -> float:
        """Calculate death rate at time t for different BD models"""
        if model in [BirthDeathModel.BCSTDCST, BirthDeathModel.BEXPDCST, BirthDeathModel.BLINDCST]:
            # Constant death rate
            return params.get('mu0', 0.1)
        
        elif model in [BirthDeathModel.BCSTDEXP, BirthDeathModel.BEXPDEXP, BirthDeathModel.BLINDEXP]:
            # Exponential death rate: mu(t) = mu0 * exp(beta * t)
            mu0 = params.get('mu0', 0.1)
            beta = params.get('beta', 0.05)
            return mu0 * math.exp(beta * t)
        
        elif model in [BirthDeathModel.BCSTDLIN, BirthDeathModel.BEXPDLIN, BirthDeathModel.BLINDLIN]:
            # Linear death rate: mu(t) = mu0 + beta * t
            mu0 = params.get('mu0', 0.1)
            beta = params.get('beta', 0.05)
            return max(0, mu0 + beta * t)
        
        return 0.1  # Default
    
    def population_size_function(self, t: float, model: CoalescentModel, params: Dict) -> float:
        """Calculate effective population size at time t for different coalescent models"""
        if model == CoalescentModel.COALCST:
            # Constant population size
            return params.get('N0', 1.0)
        
        elif model == CoalescentModel.COALEXP:
            # Exponential population growth: N(t) = N0 * exp(r * t)
            N0 = params.get('N0', 1.0)
            r = params.get('r', 0.1)
            return N0 * math.exp(r * t)
        
        elif model == CoalescentModel.COALLIN:
            # Linear population growth: N(t) = N0 + r * t
            N0 = params.get('N0', 1.0)
            r = params.get('r', 0.1)
            return max(0.01, N0 + r * t)  # Prevent zero population
        
        elif model == CoalescentModel.COALSTEP:
            # Step function population change
            N0 = params.get('N0', 1.0)
            N1 = params.get('N1', 2.0)
            t_change = params.get('t_change', 0.5)
            return N1 if t > t_change else N0
        
        elif model == CoalescentModel.COALLOG:
            # Logistic population growth: N(t) = K / (1 + ((K-N0)/N0) * exp(-r*t))
            N0 = params.get('N0', 1.0)
            K = params.get('K', 10.0)  # Carrying capacity
            r = params.get('r', 0.1)
            if K == N0:
                return N0
            return K / (1 + ((K - N0) / N0) * math.exp(-r * t))
        
        return 1.0  # Default
    
    def calculate_bd_likelihood(self, tree: dendropy.Tree, bd_model: BirthDeathModel, params: Dict) -> float:
        """Calculate likelihood under custom birth-death model"""
        try:
            n = len(tree.leaf_nodes())
            if n < 2:
                return -np.inf
            
            log_likelihood = 0.0
            
            # Get all node times
            tree.calc_node_ages()
            
            # Calculate likelihood contributions
            for node in tree.postorder_node_iter():
                if node.edge_length is not None and node.edge_length > 0:
                    # Time at start and end of branch
                    t_start = node.age + node.edge_length if node.age is not None else 0
                    t_end = node.age if node.age is not None else 0
                    
                    # Integrate rates over branch
                    dt = 0.01  # Small time step for numerical integration
                    times = np.arange(t_end, t_start, dt)
                    
                    if len(times) > 0:
                        birth_rates = [self.birth_rate_function(t, bd_model, params) for t in times]
                        death_rates = [self.death_rate_function(t, bd_model, params) for t in times]
                        
                        # Simpson's rule integration approximation
                        avg_birth = np.mean(birth_rates)
                        avg_death = np.mean(death_rates)
                        
                        # Branch survival probability
                        log_likelihood -= (avg_birth + avg_death) * node.edge_length
                
                # Speciation events
                if not node.is_leaf() and len(node.child_nodes()) == 2:
                    node_time = node.age if node.age is not None else 0
                    birth_rate = self.birth_rate_function(node_time, bd_model, params)
                    log_likelihood += math.log(max(birth_rate, 1e-10))
            
            return log_likelihood
            
        except Exception as e:
            print(f"Error in BD likelihood calculation: {e}")
            return -np.inf
    
    def calculate_coalescent_likelihood(self, tree: dendropy.Tree, coal_model: CoalescentModel, params: Dict) -> float:
        """Calculate likelihood under custom coalescent model"""
        try:
            n = len(tree.leaf_nodes())
            if n < 2:
                return -np.inf
            
            log_likelihood = 0.0
            
            # Get coalescent events
            tree.calc_node_ages()
            coalescent_events = []
            
            for node in tree.postorder_node_iter():
                if not node.is_leaf():
                    lineages = len(node.leaf_nodes())
                    time = node.age if node.age is not None else 0
                    coalescent_events.append((time, lineages))
            
            coalescent_events.sort()  # Sort by time
            
            # Calculate likelihood for each coalescent event
            for i, (t, k) in enumerate(coalescent_events):
                if k > 1:
                    N_t = self.population_size_function(t, coal_model, params)
                    
                    # Coalescent rate
                    coal_rate = k * (k - 1) / (2 * N_t)
                    log_likelihood += math.log(max(coal_rate, 1e-10))
                    
                    # Waiting time to next coalescent event
                    if i < len(coalescent_events) - 1:
                        next_time = coalescent_events[i + 1][0]
                        waiting_time = next_time - t
                        log_likelihood -= coal_rate * waiting_time
            
            return log_likelihood
            
        except Exception as e:
            print(f"Error in coalescent likelihood calculation: {e}")
            return -np.inf
    
    def calculate_aic(self, log_likelihood: float, num_params: int) -> float:
        """Calculate AIC score"""
        if log_likelihood == -np.inf:
            return np.inf
        return 2 * num_params - 2 * log_likelihood
    
    def calculate_aic_weights(self, aic_scores: Dict[str, float]) -> Dict[str, float]:
        """Calculate AIC weights for model selection"""
        # Filter out infinite AIC values
        valid_aic = {k: v for k, v in aic_scores.items() if not np.isinf(v)}
        
        if not valid_aic:
            # If all AIC values are infinite, return equal weights
            return {k: 1.0/len(aic_scores) for k in aic_scores.keys()}
        
        min_aic = min(valid_aic.values())
        delta_aic = {model: aic - min_aic for model, aic in valid_aic.items()}
        
        # Calculate relative likelihoods
        rel_likelihoods = {model: math.exp(-0.5 * delta) for model, delta in delta_aic.items()}
        
        # Normalize to get weights
        total_likelihood = sum(rel_likelihoods.values())
        weights = {model: rl / total_likelihood for model, rl in rel_likelihoods.items()}
        
        # Add zero weights for infinite AIC models
        for model in aic_scores:
            if model not in weights:
                weights[model] = 0.0
        
        return weights
    
    def get_model_parameters_count(self, model: Union[BirthDeathModel, CoalescentModel]) -> int:
        """Get number of parameters for each model"""
        if isinstance(model, BirthDeathModel):
            if model == BirthDeathModel.BCSTDCST:
                return 2  # lambda0, mu0
            elif model in [BirthDeathModel.BEXPDCST, BirthDeathModel.BLINDCST, 
                          BirthDeathModel.BCSTDEXP, BirthDeathModel.BCSTDLIN]:
                return 3  # lambda0, mu0, alpha/beta
            else:
                return 4  # lambda0, mu0, alpha, beta
        
        elif isinstance(model, CoalescentModel):
            if model == CoalescentModel.COALCST:
                return 1  # N0
            elif model in [CoalescentModel.COALEXP, CoalescentModel.COALLIN]:
                return 2  # N0, r
            elif model == CoalescentModel.COALSTEP:
                return 3  # N0, N1, t_change
            elif model == CoalescentModel.COALLOG:
                return 3  # N0, K, r
        
        return 1  # Default
    
    def fit_models_to_subtree(self, subtree: dendropy.Tree, 
                             bd_models: List[BirthDeathModel], 
                             coal_models: List[CoalescentModel],
                             bd_params: Dict, coal_params: Dict) -> Dict[str, float]:
        """Fit multiple models to a subtree and return AIC scores"""
        aic_scores = {}
        
        # Fit birth-death models
        for bd_model in bd_models:
            try:
                likelihood = self.calculate_bd_likelihood(subtree, bd_model, bd_params)
                num_params = self.get_model_parameters_count(bd_model)
                aic = self.calculate_aic(likelihood, num_params)
                aic_scores[f"BD_{bd_model.name}"] = aic
            except Exception as e:
                print(f"Error fitting BD model {bd_model.name}: {e}")
                aic_scores[f"BD_{bd_model.name}"] = np.inf
        
        # Fit coalescent models
        for coal_model in coal_models:
            try:
                likelihood = self.calculate_coalescent_likelihood(subtree, coal_model, coal_params)
                num_params = self.get_model_parameters_count(coal_model)
                aic = self.calculate_aic(likelihood, num_params)
                aic_scores[f"COAL_{coal_model.name}"] = aic
            except Exception as e:
                print(f"Error fitting coalescent model {coal_model.name}: {e}")
                aic_scores[f"COAL_{coal_model.name}"] = np.inf
        
        return aic_scores
    
    def determine_transition_points(self, tree: dendropy.Tree, 
                                   bd_models: List[BirthDeathModel],
                                   coal_models: List[CoalescentModel],
                                   bd_params: Dict, coal_params: Dict,
                                   window_size: int = 5) -> List[Tuple[dendropy.Node, Dict[str, float]]]:
        """Determine transition points between models based on AIC weights"""
        transition_points = []
        
        # Get internal nodes sorted by height
        internal_nodes = [node for node in tree.postorder_node_iter() if not node.is_leaf()]
        internal_nodes.sort(key=lambda x: x.distance_from_tip())
        
        for i in range(0, len(internal_nodes), window_size):
            window_nodes = internal_nodes[i:i+window_size]
            
            for node in window_nodes:
                if len(node.leaf_nodes()) >= 3:  # Need minimum taxa for meaningful analysis
                    try:
                        subtree = node.extract_subtree()
                        
                        # Fit all models and calculate AIC
                        aic_scores = self.fit_models_to_subtree(subtree, bd_models, coal_models, 
                                                               bd_params, coal_params)
                        
                        # Calculate AIC weights
                        weights = self.calculate_aic_weights(aic_scores)
                        
                        transition_points.append((node, weights))
                        
                    except Exception as e:
                        print(f"Error processing node: {e}")
                        continue
        
        return transition_points
    
    def generate_hybrid_tree(self, n_taxa: int, 
                           bd_models: List[BirthDeathModel],
                           coal_models: List[CoalescentModel],
                           bd_params: Dict, coal_params: Dict,
                           transition_threshold: float = 0.3) -> dendropy.Tree:
        """Generate a hybrid tree with AIC-weighted transitions"""
        # Start with a simple base tree structure
        base_tree = dendropy.simulate.birth_death_tree(
            birth_rate=bd_params.get('lambda0', 0.5),
            death_rate=bd_params.get('mu0', 0.1),
            num_extant_tips=n_taxa,
            taxon_namespace=self.taxa_namespace
        )
        
        # Determine transition points
        transitions = self.determine_transition_points(base_tree, bd_models, coal_models, 
                                                     bd_params, coal_params)
        
        # Store transition information
        for node, weights in transitions:
            # Find best model
            best_model = max(weights.items(), key=lambda x: x[1])
            
            self.transition_points.append({
                'node_height': node.distance_from_tip(),
                'best_model': best_model[0],
                'best_weight': best_model[1],
                'all_weights': weights,
                'n_taxa': len(node.leaf_nodes())
            })
        
        return base_tree
    
    def get_transition_summary(self) -> Dict:
        """Get summary of model transitions in the hybrid tree"""
        if not self.transition_points:
            return {}
        
        # Count model usage
        model_counts = {}
        for transition in self.transition_points:
            model = transition['best_model']
            model_counts[model] = model_counts.get(model, 0) + 1
        
        summary = {
            'total_transitions': len(self.transition_points),
            'model_usage': model_counts,
            'transition_details': self.transition_points
        }
        
        return summary

# Example usage
if __name__ == "__main__":
    # Create taxon namespace
    taxa = dendropy.TaxonNamespace(['Species_' + str(i) for i in range(1, 21)])
    
    # Initialize hybrid tree generator
    generator = HybridTreeGenerator(taxa)
    
    # Define models to test
    bd_models = [
        BirthDeathModel.BCSTDCST,
        BirthDeathModel.BEXPDCST,
        BirthDeathModel.BLINDCST,
        BirthDeathModel.BCSTDEXP
    ]
    
    coal_models = [
        CoalescentModel.COALCST,
        CoalescentModel.COALEXP,
        CoalescentModel.COALLIN
    ]
    
    # Define model parameters
    bd_params = {
        'lambda0': 0.8,
        'mu0': 0.2,
        'alpha': 0.1,
        'beta': 0.05
    }
    
    coal_params = {
        'N0': 2.0,
        'r': 0.1,
        'K': 10.0,
        'N1': 5.0,
        't_change': 0.5
    }
    
    # Generate hybrid tree
    print("Generating hybrid tree with custom models...")
    hybrid_tree = generator.generate_hybrid_tree(
        n_taxa=20,
        bd_models=bd_models,
        coal_models=coal_models,
        bd_params=bd_params,
        coal_params=coal_params,
        transition_threshold=0.3
    )
    
    # Print tree
    print("\nHybrid Tree:")
    print(hybrid_tree.as_string(schema="newick"))
    
    # Get transition summary
    summary = generator.get_transition_summary()
    print("\nTransition Summary:")
    print(f"Total transitions: {summary.get('total_transitions', 0)}")
    print(f"Model usage: {summary.get('model_usage', {})}")
    
    # Print detailed transition information
    if summary.get('transition_details'):
        print("\nDetailed Transitions:")
        for i, transition in enumerate(summary['transition_details'][:5]):  # Show first 5
            print(f"Transition {i+1}:")
            print(f"  Node height: {transition['node_height']:.4f}")
            print(f"  Best model: {transition['best_model']}")
            print(f"  Best weight: {transition['best_weight']:.4f}")
            print(f"  Taxa in subtree: {transition['n_taxa']}")
            print()